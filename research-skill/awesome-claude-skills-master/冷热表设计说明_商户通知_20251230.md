# 冷/热/归档表设计说明（以商户通知为例）

## 1. 目标与背景

商户通知表（`t_mch_notify`）典型特征是 **高频写入 + 高频查询**：

- 业务侧持续写入通知记录，并不断更新状态、最后回调时间等字段；
- 任务侧周期性扫描“待重试”的记录；
- 管理端需要按“已完成 / 未完成”、失败原因等维度进行检索与统计。

当数据量持续增长时，单表会把两种完全不同的访问模式混在一起：

- **热数据（Hot）**：近几天内的重试与状态更新（读写频繁、更新密集）
- **冷数据（Cold）**：历史已完成记录（写入极少、以查询/统计为主）

因此引入冷热分层，核心目标是：

1. **不改现有业务代码与 SQL 入口**（对外仍使用 `t_mch_notify` 作为表名）  
2. 将近实时读写压力留在小表（Hot），历史数据沉淀到冷表/归档表（Cold / Archive）  
3. 通过字段与索引增强，让“未完成 / 待重试 / 失败统计”等查询更快、更稳定  

---

## 2. 数据分层模型（表职责）

| 数据层 | 表名 | 保留窗口 | 读写特征 | 用途 |
|---|---|---:|---|---|
| 热数据（Hot） | `t_mch_notify_active` | 0 ~ 3 天 | 高写入、高更新、高频扫描 | 重试、状态变更、最近数据查询 |
| 冷数据（Cold） | `t_mch_notify_history` | 3 ~ 90 天 | 低写入（由迁移任务写入）、基本只读 | 历史查询、统计、追溯 |
| 极冷数据（Archive） | `t_mch_notify_archive` | 90 天以上 | 几乎只读 | 审计/极少数追溯，降低存储与维护成本 |
| 兼容入口（对外不变） | `t_mch_notify` | 与模式相关 | 对外保持不变 | **实现不改代码的关键** |

---

## 2.1 落地模式（不改代码的关键手段）

### 冷热分表方案（推荐）

- 将 `t_mch_notify` 改为 **视图（VIEW）**，保持对外表名不变；
- 实际承载写入与扫描的是热表：`t_mch_notify_active`；
- 通过定时任务将数据分层流转：  
  - 已完成数据：`active → history`  
  - 更久远数据：`history → archive`

> 说明：当 `t_mch_notify` 为 VIEW 时，字段/索引增强脚本应作用于 `t_mch_notify_active`，避免对 VIEW 执行 `ALTER TABLE`。

---

## 3. 冷热迁移规则（核心规则）

### 3.1 Active → History（每日迁移）

**迁移条件**
- `Status = 2`（已成功 / 已完成）
- `CreateTime < now - 3 天`（窗口由 `MIGRATE_DAILY_DATA` 控制）

**执行频率**
- 每天 02:00（避开业务高峰）

**目的**
- `active` 保持“小而快”，只承载需要重试、需要频繁更新的热点数据  
- 已完成数据下沉到 `history`，降低 `active` 的索引压力与扫描成本  

---

### 3.2 History → Archive（每周归档）

**归档条件**
- `CreateTime < now - 90 天`（窗口由 `ARCHIVE_WEEKLY_DATA` 控制）

**执行频率**
- 每周日 03:00 执行一次

**目的**
- `history` 保留 3~90 天的数据，满足日常查询与追溯  
- 90 天以上进入 `archive`，控制冷表体积，长期更稳定  

---

## 4. 迁移任务设计：NotifyDataMigrationTask（active → history）

### 4.1 调度

- Cron：`0 0 2 * * ?`（每天 02:00）
- TraceId：`MIGRATE-yyyyMMddHHmmssSSS` 写入 MDC，便于全链路日志追踪

### 4.2 执行流程

1. 计算迁移时间点：`beforeTime = now - MIGRATE_DAILY_DATA`
2. `countMigratableRecords(beforeTime)` 预估迁移量
3. `migrateCompletedToHistory(beforeTime)` 分批迁移（批次循环由 Service 层负责）
4. `verifyMigration(beforeTime)` 验证 active 中是否仍存在符合迁移条件的数据
5. 每天 08:00 输出积压统计（超过阈值告警）

### 4.3 关键规则

- 仅迁移 **已完成** 状态，避免影响仍可能重试的数据  
- Service 建议采用 **“插入目标表 → 删除源表”** 的方式  
  - 两步要么同事务，要么保证幂等可重跑  
- 大批量迁移必须分批（例如 1000~5000 / 批），避免长事务与大锁  

---

## 5. 归档任务设计：NotifyArchiveTask（history → archive）

### 5.1 调度

- Cron：`0 0 3 ? * SUN`（每周日 03:00）
- TraceId：`ARCHIVE-yyyyMMddHHmmssSSS`

### 5.2 执行流程

1. 计算归档时间点：`beforeTime = now - ARCHIVE_WEEKLY_DATA`
2. `countArchivableRecords(beforeTime)` 预估归档量
3. `archiveHistoryToArchive(beforeTime)` 分批归档
4. `verifyArchive(beforeTime)` 验证 history 中是否仍存在符合归档条件的数据
5. 每月 1 号 09:00 输出历史数据分布报告，并对积压情况告警

### 5.3 关键规则

- 归档频率低，但单次数据量可能较大，因此更需要分批处理  
- 对 `archive` 的长期策略建议：
  - 超过 1 年的数据可导出备份后删除（视合规与业务要求决定）

---

## 6. 一句话总结

本方案的核心在于：  
**通过“视图 + 定时迁移/归档”的数据库分层设计，把大表拆成热/冷/归档三层，同时保持对外表名不变，从而实现“不改现有代码”的冷热分离。**
